package ca.coglinc.gradle.plugins.javacc;

import static org.junit.Assert.assertEquals;

import java.io.File;
import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;

import org.gradle.api.Project;
import org.gradle.api.file.FileCollection;
import org.gradle.api.file.FileVisitor;
import org.gradle.api.file.RelativePath;
import org.gradle.api.tasks.TaskExecutionException;
import org.gradle.api.tasks.TaskValidationException;
import org.gradle.testfixtures.ProjectBuilder;
import org.hamcrest.Matcher;
import org.hamcrest.collection.IsArrayContainingInOrder;
import org.junit.After;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Answers;
import org.mockito.Mockito;

public class CompileJavaccTaskTest {
    private static final String[] GENERATED_FILES = {"JavaccOutputTest.java", "JavaccOutputTestConstants.java", "JavaccOutputTestTokenManager.java",
        "ParseException.java", "SimpleCharStream.java", "Token.java", "TokenMgrError.java" };

    private CompileJavaccTask task;

    @Before
    public void setUp() {
        Project project = ProjectBuilder.builder().build();
        applyJavaccPluginToProject(project);

        task = (CompileJavaccTask) project.getTasks().findByName(CompileJavaccTask.TASK_NAME_VALUE);
    }

    private void applyJavaccPluginToProject(Project project) {
        Map<String, String> pluginNames = new HashMap<String, String>(1);
        pluginNames.put("plugin", "ca.coglinc.javacc");

        project.apply(pluginNames);
    }

    @After
    public void tearDown() {
        final File outputDirectory = new File(getClass().getResource("/").getFile() + "output");
        if (outputDirectory.exists()) {
            deleteDirectories(outputDirectory);
        }
    }

    private void deleteDirectories(File outputDirectory) {
        for (File outputFile : outputDirectory.listFiles()) {
            if (outputFile.isDirectory()) {
                deleteDirectories(outputFile);
            } else {
                outputFile.delete();
            }
        }
        outputDirectory.delete();
    }

    @Test
    public void compileJavaccToJavaCompilesEachJavaccInputFileToJava() {
        setTaskInputDirectory("/javacc/inputWithSubFolder");
        final File outputDirectory = setTaskOutputDirectory("output");
        final File subOutputDirectory = new File(outputDirectory, "sub");

        task.execute();

        Assert.assertTrue(subOutputDirectory.isDirectory());
        Assert.assertEquals(CompileJavaccTaskTest.GENERATED_FILES.length, subOutputDirectory.list().length);
        Assert.assertTrue(Arrays.asList(subOutputDirectory.list()).containsAll(Arrays.asList(CompileJavaccTaskTest.GENERATED_FILES)));
    }

    @Test
    public void compileJavaccToJavaCompilesEachJavaccInputFileToJavaSubDirectory() {
        setTaskInputDirectory("/javacc/input");
        final File outputDirectory = setTaskOutputDirectory("output");

        task.execute();

        Assert.assertTrue(outputDirectory.isDirectory());
        Assert.assertEquals(CompileJavaccTaskTest.GENERATED_FILES.length, outputDirectory.list().length);
        Assert.assertTrue(Arrays.asList(outputDirectory.list()).containsAll(Arrays.asList(CompileJavaccTaskTest.GENERATED_FILES)));
    }
    
    @Test
    public void compileJavaccToJavaCopiesNonJavaccFilesToOutputDirectory() {
        setTaskInputDirectory("/javacc/inputWithNonJavaccFiles");
        final File outputDirectory = setTaskOutputDirectory("output");
        task.include("**/*.txt");

        task.execute();

        Assert.assertTrue(outputDirectory.isDirectory());
        Assert.assertEquals(1 + CompileJavaccTaskTest.GENERATED_FILES.length, outputDirectory.list().length);
        Assert.assertTrue(Arrays.asList(outputDirectory.list()).containsAll(Arrays.asList(CompileJavaccTaskTest.GENERATED_FILES)));
        Assert.assertTrue(Arrays.asList(outputDirectory.list()).containsAll(Arrays.asList("test.txt")));
    }

    @Test
    public void compileJavaccToJavaCompilesEachJavaccInputFileToJavaMultipleSources() {
        setTaskInputDirectory("/javacc/input");
        addTaskInputDirectory("/javacc/inputWithSubFolder");

        final File outputDirectory = setTaskOutputDirectory("output");

        task.execute();

        Assert.assertTrue(outputDirectory.isDirectory());
        // Generated files for /javacc/input + directory sub from files generated by /javacc/inputWithSubFolder/sub
        Assert.assertEquals(CompileJavaccTaskTest.GENERATED_FILES.length + 1, outputDirectory.list().length);
        Assert.assertTrue(Arrays.asList(outputDirectory.list()).containsAll(Arrays.asList(CompileJavaccTaskTest.GENERATED_FILES)));

        final File subOutputDirectory = new File(outputDirectory, "sub");
        Assert.assertTrue(subOutputDirectory.isDirectory());
        Assert.assertEquals(CompileJavaccTaskTest.GENERATED_FILES.length, subOutputDirectory.list().length);
        Assert.assertTrue(Arrays.asList(subOutputDirectory.list()).containsAll(Arrays.asList(CompileJavaccTaskTest.GENERATED_FILES)));
    }

    private File addTaskInputDirectory(final String inputDirectoryName) {
        final File inputDirectory = new File(getClass().getResource(inputDirectoryName).getFile());
        task.source(inputDirectory);

        return inputDirectory;
    }

    private File setTaskInputDirectory(final String inputDirectoryName) {
        final File inputDirectory = new File(getClass().getResource(inputDirectoryName).getFile());
        task.setInputDirectory(inputDirectory);

        return inputDirectory;
    }

    private File setTaskOutputDirectory(final String outputDirectoryName) {
        final File outputDirectory = new File(getClass().getResource("/").getFile() + outputDirectoryName);
        task.setOutputDirectory(outputDirectory);
        return outputDirectory;
    }

    @Test
    public void compileJavaccToJavaDoesNotGenerateAnythingIfNoInputFiles() {
        testExecuteTaskWithNoInputFiles(new File[0]);
    }

    private void testExecuteTaskWithNoInputFiles(File[] noInputFiles) {
        final File inputDirectory = Mockito.mock(File.class, Answers.RETURNS_MOCKS.get());
        Mockito.when(inputDirectory.listFiles()).thenReturn(noInputFiles);
        Mockito.when(inputDirectory.exists()).thenReturn(Boolean.TRUE);
        Mockito.when(inputDirectory.isDirectory()).thenReturn(Boolean.TRUE);
        task.setSource(inputDirectory);
        final File outputDirectory = new File(getClass().getResource("/").getFile() + "output");
        task.setOutputDirectory(outputDirectory);

        task.execute();

        Assert.assertFalse(outputDirectory.isDirectory());
    }

    @Test
    public void compileJavaccToJavaDoesNotGenerateAnythingIfInputFilesNull() {
        testExecuteTaskWithNoInputFiles(null);
    }

    @Test
    public void compileJavaccToJavaCompilesEachJavaccInputFileToJavaIntoItsPackage() {
        setTaskInputDirectory("/javacc/inputWithPackages");
        final File outputDirectory = setTaskOutputDirectory("output");

        task.execute();

        Assert.assertTrue(outputDirectory.isDirectory());
        Assert.assertEquals(1, outputDirectory.list().length);
        Assert.assertEquals("test", outputDirectory.list()[0]);
        final String[] filesInTestPackageUnderOutputDirectory = outputDirectory.listFiles()[0].list();
        Assert.assertEquals(CompileJavaccTaskTest.GENERATED_FILES.length, filesInTestPackageUnderOutputDirectory.length);
        Assert.assertTrue(Arrays.asList(filesInTestPackageUnderOutputDirectory).containsAll(Arrays.asList(CompileJavaccTaskTest.GENERATED_FILES)));
    }

    @Test(expected = TaskExecutionException.class)
    public void compileJavaccFailsWhenParserGeneratesAnError() {
        setTaskInputDirectory("/javacc/inputWithErrors");
        setTaskOutputDirectory("output");

        task.execute();
    }

    @Test(expected = IllegalArgumentException.class)
    public void inputDirectoryIsMandatory() {
        task.setSource(null);
        setTaskOutputDirectory("output");

        task.execute();
    }

    @Test(expected = TaskValidationException.class)
    public void outputDirectoryIsMandatory() {
        setTaskInputDirectory("/javacc/input");
        task.setOutputDirectory((File) null);

        try {
            task.execute();
        } catch (TaskExecutionException e) {
            Assert.assertTrue(e.getCause() instanceof IllegalArgumentException);
            throw e;
        }
    }

    @Test
    public void taskInputsAreInputDirectory() {
        setTaskInputDirectory("/javacc/input");

        task.execute();

        FileCollection inputFiles = task.getInputs().getFiles();
        Assert.assertEquals(1, inputFiles.getFiles().size());
        Assert.assertEquals("JavaccOutputTest.jj", ((File) inputFiles.getFiles().toArray()[0]).getName());
    }

    @Test
    public void taskOutputsAreOutputDirectory() {
        setTaskInputDirectory("/javacc/input");
        setTaskOutputDirectory("output");

        task.execute();

        FileCollection outputFiles = task.getOutputs().getFiles();
        Assert.assertEquals(1, outputFiles.getFiles().size());
        Assert.assertEquals("output", ((File) outputFiles.getFiles().toArray()[0]).getName());
    }

    @Test
    public void javaccArgumentsAreOutputDirectoryAndFileToCompileWhenNoJavaccArgumentsProvided() {
        File inputDirectory = setTaskInputDirectory("/javacc/input");
        File outputDirectory = setTaskOutputDirectory("output");
        File tempOutputDirectory = new File(outputDirectory, "tmp");

        RelativePath inputRelativePath = Mockito.mock(RelativePath.class);
        Mockito.when(inputRelativePath.getPathString()).thenReturn("Grammar.jj");
        Mockito.when(inputRelativePath.getFile(inputDirectory)).thenReturn(new File(inputDirectory, "Grammar.jj"));
        Mockito.when(inputRelativePath.getFile(tempOutputDirectory)).thenReturn(new File(tempOutputDirectory, "Grammar.jj"));

        String inputAbsolutePath = inputRelativePath.getFile(inputDirectory).getAbsolutePath();

        String[] javaccArgumentsForCommandLine = task.buildProgramArguments(inputDirectory, inputRelativePath);

        Assert.assertEquals(2, javaccArgumentsForCommandLine.length);
        Assert.assertThat(javaccArgumentsForCommandLine,
            IsArrayContainingInOrder.arrayContaining("-OUTPUT_DIRECTORY=" + tempOutputDirectory.getAbsolutePath(), inputAbsolutePath));
    }

    @Test
    public void javaccArgumentsAreOutputDirectoryAndFileToCompileWhenEmptyJavaccArgumentsProvided() {
        File inputDirectory = setTaskInputDirectory("/javacc/input");
        File outputDirectory = setTaskOutputDirectory("output");
        File tempOutputDirectory = new File(outputDirectory, "tmp");

        RelativePath inputRelativePath = Mockito.mock(RelativePath.class);
        Mockito.when(inputRelativePath.getPathString()).thenReturn("Grammar.jj");
        Mockito.when(inputRelativePath.getFile(inputDirectory)).thenReturn(new File(inputDirectory, "Grammar.jj"));
        Mockito.when(inputRelativePath.getFile(tempOutputDirectory)).thenReturn(new File(tempOutputDirectory, "Grammar.jj"));

        String inputAbsolutePath = inputRelativePath.getFile(inputDirectory).getAbsolutePath();

        task.setArguments(new HashMap<String, String>(0));

        String[] javaccArgumentsForCommandLine = task.buildProgramArguments(inputDirectory, inputRelativePath);

        Assert.assertEquals(2, javaccArgumentsForCommandLine.length);
        Assert.assertThat(javaccArgumentsForCommandLine,
            IsArrayContainingInOrder.arrayContaining("-OUTPUT_DIRECTORY=" + tempOutputDirectory.getAbsolutePath(), inputAbsolutePath));
    }

    @Test
    public void javaccArgumentsAreOutputDirectoryFileToCompileAndProvidedArguments() {
        File inputDirectory = setTaskInputDirectory("/javacc/input");
        File outputDirectory = setTaskOutputDirectory("output");
        File tempOutputDirectory = new File(outputDirectory, "tmp");

        RelativePath inputRelativePath = Mockito.mock(RelativePath.class);
        Mockito.when(inputRelativePath.getPathString()).thenReturn("Grammar.jj");
        Mockito.when(inputRelativePath.getFile(inputDirectory)).thenReturn(new File(inputDirectory, "Grammar.jj"));
        Mockito.when(inputRelativePath.getFile(tempOutputDirectory)).thenReturn(new File(tempOutputDirectory, "Grammar.jj"));

        String inputAbsolutePath = inputRelativePath.getFile(inputDirectory).getAbsolutePath();

        LinkedHashMap<String, String> javaccArguments = new LinkedHashMap<String, String>(1);
        javaccArguments.put("static", Boolean.FALSE.toString());
        task.setArguments(javaccArguments);

        String[] javaccArgumentsForCommandLine = task.buildProgramArguments(inputDirectory, inputRelativePath);

        final int outputDirectoryAndProvidedArgumentAndFileToCompile = 3;
        Assert.assertEquals(outputDirectoryAndProvidedArgumentAndFileToCompile, javaccArgumentsForCommandLine.length);
        final Matcher<String[]> containsOuputDirectoryFileToCompileAndOtherProvidedArguments = IsArrayContainingInOrder.arrayContaining(
            "-static=false", "-OUTPUT_DIRECTORY=" + tempOutputDirectory.getAbsolutePath(), inputAbsolutePath);
        Assert.assertThat(javaccArgumentsForCommandLine, containsOuputDirectoryFileToCompileAndOtherProvidedArguments);
    }

    @Test
    public void getFileVisitorReturnsInstanceOfJavaccSourceFileVisitor() {
        FileVisitor sourceFileVisitor = task.getJavaccSourceFileVisitor();

        Assert.assertTrue(sourceFileVisitor instanceof JavaccSourceFileVisitor);
    }
    
    @Test
    public void supportsDotJjFiles() {
        String supportedSuffix = task.supportedSuffix();
        
        assertEquals(".jj", supportedSuffix);
    }
}
